// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: units.sql

package database

import (
	"context"
	"encoding/json"

	"github.com/google/uuid"
)

const createUnit = `-- name: CreateUnit :one
INSERT INTO units (
  faction_id, name, description, is_manifestation, is_unique,
  move, health_wounds, save_stats, ward_fnp, invuln_save, 
  control_oc, toughness, leadership_bravery, points,
  additional_stats,
  summon_cost, banishment,
  min_unit_size, max_unit_size, matched_play, version, source
)
VALUES (
  $1, $2, $3, $4, $5,
  $6, $7, $8, $9, $10, $11, $12, $13, $14, $15,
  $16, $17,
  $18, $19, $20, $21, $22
)
RETURNING id, faction_id, name, description, is_manifestation, is_unique, move, health_wounds, save_stats, ward_fnp, invuln_save, control_oc, toughness, leadership_bravery, points, additional_stats, summon_cost, banishment, min_unit_size, max_unit_size, matched_play, version, source, created_at, updated_at
`

type CreateUnitParams struct {
	FactionID         uuid.UUID
	Name              string
	Description       string
	IsManifestation   bool
	IsUnique          bool
	Move              string
	HealthWounds      string
	SaveStats         string
	WardFnp           string
	InvulnSave        string
	ControlOc         string
	Toughness         string
	LeadershipBravery string
	Points            int32
	AdditionalStats   json.RawMessage
	SummonCost        string
	Banishment        string
	MinUnitSize       int32
	MaxUnitSize       int32
	MatchedPlay       bool
	Version           string
	Source            string
}

func (q *Queries) CreateUnit(ctx context.Context, arg CreateUnitParams) (Unit, error) {
	row := q.db.QueryRow(ctx, createUnit,
		arg.FactionID,
		arg.Name,
		arg.Description,
		arg.IsManifestation,
		arg.IsUnique,
		arg.Move,
		arg.HealthWounds,
		arg.SaveStats,
		arg.WardFnp,
		arg.InvulnSave,
		arg.ControlOc,
		arg.Toughness,
		arg.LeadershipBravery,
		arg.Points,
		arg.AdditionalStats,
		arg.SummonCost,
		arg.Banishment,
		arg.MinUnitSize,
		arg.MaxUnitSize,
		arg.MatchedPlay,
		arg.Version,
		arg.Source,
	)
	var i Unit
	err := row.Scan(
		&i.ID,
		&i.FactionID,
		&i.Name,
		&i.Description,
		&i.IsManifestation,
		&i.IsUnique,
		&i.Move,
		&i.HealthWounds,
		&i.SaveStats,
		&i.WardFnp,
		&i.InvulnSave,
		&i.ControlOc,
		&i.Toughness,
		&i.LeadershipBravery,
		&i.Points,
		&i.AdditionalStats,
		&i.SummonCost,
		&i.Banishment,
		&i.MinUnitSize,
		&i.MaxUnitSize,
		&i.MatchedPlay,
		&i.Version,
		&i.Source,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteUnit = `-- name: DeleteUnit :exec
DELETE FROM units
WHERE id = $1
`

func (q *Queries) DeleteUnit(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteUnit, id)
	return err
}

const getAllUnits = `-- name: GetAllUnits :many
SELECT id, faction_id, name, description, is_manifestation, is_unique, move, health_wounds, save_stats, ward_fnp, invuln_save, control_oc, toughness, leadership_bravery, points, additional_stats, summon_cost, banishment, min_unit_size, max_unit_size, matched_play, version, source, created_at, updated_at
FROM units
WHERE is_manifestation = false
ORDER BY faction_id, name ASC
`

func (q *Queries) GetAllUnits(ctx context.Context) ([]Unit, error) {
	rows, err := q.db.Query(ctx, getAllUnits)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Unit
	for rows.Next() {
		var i Unit
		if err := rows.Scan(
			&i.ID,
			&i.FactionID,
			&i.Name,
			&i.Description,
			&i.IsManifestation,
			&i.IsUnique,
			&i.Move,
			&i.HealthWounds,
			&i.SaveStats,
			&i.WardFnp,
			&i.InvulnSave,
			&i.ControlOc,
			&i.Toughness,
			&i.LeadershipBravery,
			&i.Points,
			&i.AdditionalStats,
			&i.SummonCost,
			&i.Banishment,
			&i.MinUnitSize,
			&i.MaxUnitSize,
			&i.MatchedPlay,
			&i.Version,
			&i.Source,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getManifestationByID = `-- name: GetManifestationByID :one
SELECT id, faction_id, name, description, is_manifestation, is_unique, move, health_wounds, save_stats, ward_fnp, invuln_save, control_oc, toughness, leadership_bravery, points, additional_stats, summon_cost, banishment, min_unit_size, max_unit_size, matched_play, version, source, created_at, updated_at
FROM units
WHERE id = $1 AND is_manifestation = true
`

func (q *Queries) GetManifestationByID(ctx context.Context, id uuid.UUID) (Unit, error) {
	row := q.db.QueryRow(ctx, getManifestationByID, id)
	var i Unit
	err := row.Scan(
		&i.ID,
		&i.FactionID,
		&i.Name,
		&i.Description,
		&i.IsManifestation,
		&i.IsUnique,
		&i.Move,
		&i.HealthWounds,
		&i.SaveStats,
		&i.WardFnp,
		&i.InvulnSave,
		&i.ControlOc,
		&i.Toughness,
		&i.LeadershipBravery,
		&i.Points,
		&i.AdditionalStats,
		&i.SummonCost,
		&i.Banishment,
		&i.MinUnitSize,
		&i.MaxUnitSize,
		&i.MatchedPlay,
		&i.Version,
		&i.Source,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getManifestations = `-- name: GetManifestations :many
SELECT id, faction_id, name, description, is_manifestation, is_unique, move, health_wounds, save_stats, ward_fnp, invuln_save, control_oc, toughness, leadership_bravery, points, additional_stats, summon_cost, banishment, min_unit_size, max_unit_size, matched_play, version, source, created_at, updated_at
FROM units
WHERE is_manifestation = true
ORDER BY faction_id, name ASC
`

func (q *Queries) GetManifestations(ctx context.Context) ([]Unit, error) {
	rows, err := q.db.Query(ctx, getManifestations)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Unit
	for rows.Next() {
		var i Unit
		if err := rows.Scan(
			&i.ID,
			&i.FactionID,
			&i.Name,
			&i.Description,
			&i.IsManifestation,
			&i.IsUnique,
			&i.Move,
			&i.HealthWounds,
			&i.SaveStats,
			&i.WardFnp,
			&i.InvulnSave,
			&i.ControlOc,
			&i.Toughness,
			&i.LeadershipBravery,
			&i.Points,
			&i.AdditionalStats,
			&i.SummonCost,
			&i.Banishment,
			&i.MinUnitSize,
			&i.MaxUnitSize,
			&i.MatchedPlay,
			&i.Version,
			&i.Source,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNonManifestationUnits = `-- name: GetNonManifestationUnits :many
SELECT id, faction_id, name, description, is_manifestation, is_unique, move, health_wounds, save_stats, ward_fnp, invuln_save, control_oc, toughness, leadership_bravery, points, additional_stats, summon_cost, banishment, min_unit_size, max_unit_size, matched_play, version, source, created_at, updated_at
FROM units
WHERE is_manifestation = false
ORDER BY faction_id, name ASC
`

func (q *Queries) GetNonManifestationUnits(ctx context.Context) ([]Unit, error) {
	rows, err := q.db.Query(ctx, getNonManifestationUnits)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Unit
	for rows.Next() {
		var i Unit
		if err := rows.Scan(
			&i.ID,
			&i.FactionID,
			&i.Name,
			&i.Description,
			&i.IsManifestation,
			&i.IsUnique,
			&i.Move,
			&i.HealthWounds,
			&i.SaveStats,
			&i.WardFnp,
			&i.InvulnSave,
			&i.ControlOc,
			&i.Toughness,
			&i.LeadershipBravery,
			&i.Points,
			&i.AdditionalStats,
			&i.SummonCost,
			&i.Banishment,
			&i.MinUnitSize,
			&i.MaxUnitSize,
			&i.MatchedPlay,
			&i.Version,
			&i.Source,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUnitByID = `-- name: GetUnitByID :one
SELECT id, faction_id, name, description, is_manifestation, is_unique, move, health_wounds, save_stats, ward_fnp, invuln_save, control_oc, toughness, leadership_bravery, points, additional_stats, summon_cost, banishment, min_unit_size, max_unit_size, matched_play, version, source, created_at, updated_at
FROM units
WHERE id = $1
`

func (q *Queries) GetUnitByID(ctx context.Context, id uuid.UUID) (Unit, error) {
	row := q.db.QueryRow(ctx, getUnitByID, id)
	var i Unit
	err := row.Scan(
		&i.ID,
		&i.FactionID,
		&i.Name,
		&i.Description,
		&i.IsManifestation,
		&i.IsUnique,
		&i.Move,
		&i.HealthWounds,
		&i.SaveStats,
		&i.WardFnp,
		&i.InvulnSave,
		&i.ControlOc,
		&i.Toughness,
		&i.LeadershipBravery,
		&i.Points,
		&i.AdditionalStats,
		&i.SummonCost,
		&i.Banishment,
		&i.MinUnitSize,
		&i.MaxUnitSize,
		&i.MatchedPlay,
		&i.Version,
		&i.Source,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUnitsByFaction = `-- name: GetUnitsByFaction :many
SELECT id, faction_id, name, description, is_manifestation, is_unique, move, health_wounds, save_stats, ward_fnp, invuln_save, control_oc, toughness, leadership_bravery, points, additional_stats, summon_cost, banishment, min_unit_size, max_unit_size, matched_play, version, source, created_at, updated_at
FROM units
WHERE faction_id = $1 AND is_manifestation = false
ORDER BY name ASC
`

func (q *Queries) GetUnitsByFaction(ctx context.Context, factionID uuid.UUID) ([]Unit, error) {
	rows, err := q.db.Query(ctx, getUnitsByFaction, factionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Unit
	for rows.Next() {
		var i Unit
		if err := rows.Scan(
			&i.ID,
			&i.FactionID,
			&i.Name,
			&i.Description,
			&i.IsManifestation,
			&i.IsUnique,
			&i.Move,
			&i.HealthWounds,
			&i.SaveStats,
			&i.WardFnp,
			&i.InvulnSave,
			&i.ControlOc,
			&i.Toughness,
			&i.LeadershipBravery,
			&i.Points,
			&i.AdditionalStats,
			&i.SummonCost,
			&i.Banishment,
			&i.MinUnitSize,
			&i.MaxUnitSize,
			&i.MatchedPlay,
			&i.Version,
			&i.Source,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUnitsByMatchedPlay = `-- name: GetUnitsByMatchedPlay :many
SELECT id, faction_id, name, description, is_manifestation, is_unique, move, health_wounds, save_stats, ward_fnp, invuln_save, control_oc, toughness, leadership_bravery, points, additional_stats, summon_cost, banishment, min_unit_size, max_unit_size, matched_play, version, source, created_at, updated_at
FROM units
WHERE faction_id = $1 AND matched_play = true AND is_manifestation = false
ORDER BY name ASC
`

func (q *Queries) GetUnitsByMatchedPlay(ctx context.Context, factionID uuid.UUID) ([]Unit, error) {
	rows, err := q.db.Query(ctx, getUnitsByMatchedPlay, factionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Unit
	for rows.Next() {
		var i Unit
		if err := rows.Scan(
			&i.ID,
			&i.FactionID,
			&i.Name,
			&i.Description,
			&i.IsManifestation,
			&i.IsUnique,
			&i.Move,
			&i.HealthWounds,
			&i.SaveStats,
			&i.WardFnp,
			&i.InvulnSave,
			&i.ControlOc,
			&i.Toughness,
			&i.LeadershipBravery,
			&i.Points,
			&i.AdditionalStats,
			&i.SummonCost,
			&i.Banishment,
			&i.MinUnitSize,
			&i.MaxUnitSize,
			&i.MatchedPlay,
			&i.Version,
			&i.Source,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateUnit = `-- name: UpdateUnit :one
UPDATE units
SET name = $2, description = $3, move = $4, health_wounds = $5, save_stats = $6, 
    ward_fnp = $7, invuln_save = $8, control_oc = $9, toughness = $10, 
    leadership_bravery = $11, points = $12, additional_stats = $13,
    summon_cost = $14, banishment = $15, min_unit_size = $16, max_unit_size = $17, 
    matched_play = $18, version = $19, source = $20, updated_at = now()
WHERE id = $1
RETURNING id, faction_id, name, description, is_manifestation, is_unique, move, health_wounds, save_stats, ward_fnp, invuln_save, control_oc, toughness, leadership_bravery, points, additional_stats, summon_cost, banishment, min_unit_size, max_unit_size, matched_play, version, source, created_at, updated_at
`

type UpdateUnitParams struct {
	ID                uuid.UUID
	Name              string
	Description       string
	Move              string
	HealthWounds      string
	SaveStats         string
	WardFnp           string
	InvulnSave        string
	ControlOc         string
	Toughness         string
	LeadershipBravery string
	Points            int32
	AdditionalStats   json.RawMessage
	SummonCost        string
	Banishment        string
	MinUnitSize       int32
	MaxUnitSize       int32
	MatchedPlay       bool
	Version           string
	Source            string
}

func (q *Queries) UpdateUnit(ctx context.Context, arg UpdateUnitParams) (Unit, error) {
	row := q.db.QueryRow(ctx, updateUnit,
		arg.ID,
		arg.Name,
		arg.Description,
		arg.Move,
		arg.HealthWounds,
		arg.SaveStats,
		arg.WardFnp,
		arg.InvulnSave,
		arg.ControlOc,
		arg.Toughness,
		arg.LeadershipBravery,
		arg.Points,
		arg.AdditionalStats,
		arg.SummonCost,
		arg.Banishment,
		arg.MinUnitSize,
		arg.MaxUnitSize,
		arg.MatchedPlay,
		arg.Version,
		arg.Source,
	)
	var i Unit
	err := row.Scan(
		&i.ID,
		&i.FactionID,
		&i.Name,
		&i.Description,
		&i.IsManifestation,
		&i.IsUnique,
		&i.Move,
		&i.HealthWounds,
		&i.SaveStats,
		&i.WardFnp,
		&i.InvulnSave,
		&i.ControlOc,
		&i.Toughness,
		&i.LeadershipBravery,
		&i.Points,
		&i.AdditionalStats,
		&i.SummonCost,
		&i.Banishment,
		&i.MinUnitSize,
		&i.MaxUnitSize,
		&i.MatchedPlay,
		&i.Version,
		&i.Source,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
