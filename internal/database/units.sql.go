// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: units.sql

package database

import (
	"context"

	"github.com/google/uuid"
)

const createUnit = `-- name: CreateUnit :one
INSERT INTO units (
  faction_id, name, points, move, health, save, ward,
  control, rend, attacks, damage, summon_cost, banishment,
  is_manifestation, min_size, max_size, version, source
)
VALUES (
  $1,$2,$3,$4,$5,$6,$7,
  $8,$9,$10,$11,$12,$13,
  $14,$15,$16,$17,$18
)
RETURNING id, faction_id, name, is_manifestation, move, health, save, ward, control, points, summon_cost, banishment, rend, attacks, damage, min_size, max_size, version, source, created_at, updated_at
`

type CreateUnitParams struct {
	FactionID       uuid.UUID
	Name            string
	Points          int32
	Move            int32
	Health          int32
	Save            string
	Ward            string
	Control         int32
	Rend            string
	Attacks         string
	Damage          string
	SummonCost      string
	Banishment      string
	IsManifestation bool
	MinSize         int32
	MaxSize         int32
	Version         string
	Source          string
}

func (q *Queries) CreateUnit(ctx context.Context, arg CreateUnitParams) (Unit, error) {
	row := q.db.QueryRow(ctx, createUnit,
		arg.FactionID,
		arg.Name,
		arg.Points,
		arg.Move,
		arg.Health,
		arg.Save,
		arg.Ward,
		arg.Control,
		arg.Rend,
		arg.Attacks,
		arg.Damage,
		arg.SummonCost,
		arg.Banishment,
		arg.IsManifestation,
		arg.MinSize,
		arg.MaxSize,
		arg.Version,
		arg.Source,
	)
	var i Unit
	err := row.Scan(
		&i.ID,
		&i.FactionID,
		&i.Name,
		&i.IsManifestation,
		&i.Move,
		&i.Health,
		&i.Save,
		&i.Ward,
		&i.Control,
		&i.Points,
		&i.SummonCost,
		&i.Banishment,
		&i.Rend,
		&i.Attacks,
		&i.Damage,
		&i.MinSize,
		&i.MaxSize,
		&i.Version,
		&i.Source,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteUnit = `-- name: DeleteUnit :exec
DELETE FROM units 
WHERE id = $1
`

func (q *Queries) DeleteUnit(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteUnit, id)
	return err
}

const getAllUnits = `-- name: GetAllUnits :many
SELECt id, faction_id, name, is_manifestation, move, health, save, ward, control, points, summon_cost, banishment, rend, attacks, damage, min_size, max_size, version, source, created_at, updated_at FROM units
`

func (q *Queries) GetAllUnits(ctx context.Context) ([]Unit, error) {
	rows, err := q.db.Query(ctx, getAllUnits)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Unit
	for rows.Next() {
		var i Unit
		if err := rows.Scan(
			&i.ID,
			&i.FactionID,
			&i.Name,
			&i.IsManifestation,
			&i.Move,
			&i.Health,
			&i.Save,
			&i.Ward,
			&i.Control,
			&i.Points,
			&i.SummonCost,
			&i.Banishment,
			&i.Rend,
			&i.Attacks,
			&i.Damage,
			&i.MinSize,
			&i.MaxSize,
			&i.Version,
			&i.Source,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getManifestationByID = `-- name: GetManifestationByID :one
SELECT id, faction_id, name, is_manifestation, move, health, save, ward, control, points, summon_cost, banishment, rend, attacks, damage, min_size, max_size, version, source, created_at, updated_at FROM units
WHERE id = $1 AND is_manifestation = TRUE
`

func (q *Queries) GetManifestationByID(ctx context.Context, id uuid.UUID) (Unit, error) {
	row := q.db.QueryRow(ctx, getManifestationByID, id)
	var i Unit
	err := row.Scan(
		&i.ID,
		&i.FactionID,
		&i.Name,
		&i.IsManifestation,
		&i.Move,
		&i.Health,
		&i.Save,
		&i.Ward,
		&i.Control,
		&i.Points,
		&i.SummonCost,
		&i.Banishment,
		&i.Rend,
		&i.Attacks,
		&i.Damage,
		&i.MinSize,
		&i.MaxSize,
		&i.Version,
		&i.Source,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getManifestations = `-- name: GetManifestations :many
SELECT id, faction_id, name, is_manifestation, move, health, save, ward, control, points, summon_cost, banishment, rend, attacks, damage, min_size, max_size, version, source, created_at, updated_at FROM units
WHERE is_manifestation = TRUE
ORDER BY name ASC
`

func (q *Queries) GetManifestations(ctx context.Context) ([]Unit, error) {
	rows, err := q.db.Query(ctx, getManifestations)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Unit
	for rows.Next() {
		var i Unit
		if err := rows.Scan(
			&i.ID,
			&i.FactionID,
			&i.Name,
			&i.IsManifestation,
			&i.Move,
			&i.Health,
			&i.Save,
			&i.Ward,
			&i.Control,
			&i.Points,
			&i.SummonCost,
			&i.Banishment,
			&i.Rend,
			&i.Attacks,
			&i.Damage,
			&i.MinSize,
			&i.MaxSize,
			&i.Version,
			&i.Source,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNonManifestationUnits = `-- name: GetNonManifestationUnits :many
SELECT id, faction_id, name, is_manifestation, move, health, save, ward, control, points, summon_cost, banishment, rend, attacks, damage, min_size, max_size, version, source, created_at, updated_at FROM units
WHERE is_manifestation = FALSE
ORDER BY name ASC
`

func (q *Queries) GetNonManifestationUnits(ctx context.Context) ([]Unit, error) {
	rows, err := q.db.Query(ctx, getNonManifestationUnits)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Unit
	for rows.Next() {
		var i Unit
		if err := rows.Scan(
			&i.ID,
			&i.FactionID,
			&i.Name,
			&i.IsManifestation,
			&i.Move,
			&i.Health,
			&i.Save,
			&i.Ward,
			&i.Control,
			&i.Points,
			&i.SummonCost,
			&i.Banishment,
			&i.Rend,
			&i.Attacks,
			&i.Damage,
			&i.MinSize,
			&i.MaxSize,
			&i.Version,
			&i.Source,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUnitByID = `-- name: GetUnitByID :one
SELECT id, faction_id, name, is_manifestation, move, health, save, ward, control, points, summon_cost, banishment, rend, attacks, damage, min_size, max_size, version, source, created_at, updated_at FROM units 
WHERE id = $1
`

func (q *Queries) GetUnitByID(ctx context.Context, id uuid.UUID) (Unit, error) {
	row := q.db.QueryRow(ctx, getUnitByID, id)
	var i Unit
	err := row.Scan(
		&i.ID,
		&i.FactionID,
		&i.Name,
		&i.IsManifestation,
		&i.Move,
		&i.Health,
		&i.Save,
		&i.Ward,
		&i.Control,
		&i.Points,
		&i.SummonCost,
		&i.Banishment,
		&i.Rend,
		&i.Attacks,
		&i.Damage,
		&i.MinSize,
		&i.MaxSize,
		&i.Version,
		&i.Source,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUnits = `-- name: GetUnits :many
SELECT id, faction_id, name, is_manifestation, move, health, save, ward, control, points, summon_cost, banishment, rend, attacks, damage, min_size, max_size, version, source, created_at, updated_at FROM units
WHERE faction_id = $1 AND is_manifestation = FALSE
ORDER BY name ASC
`

func (q *Queries) GetUnits(ctx context.Context, factionID uuid.UUID) ([]Unit, error) {
	rows, err := q.db.Query(ctx, getUnits, factionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Unit
	for rows.Next() {
		var i Unit
		if err := rows.Scan(
			&i.ID,
			&i.FactionID,
			&i.Name,
			&i.IsManifestation,
			&i.Move,
			&i.Health,
			&i.Save,
			&i.Ward,
			&i.Control,
			&i.Points,
			&i.SummonCost,
			&i.Banishment,
			&i.Rend,
			&i.Attacks,
			&i.Damage,
			&i.MinSize,
			&i.MaxSize,
			&i.Version,
			&i.Source,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
