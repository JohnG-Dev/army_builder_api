// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: units.sql

package database

import (
	"context"

	"github.com/google/uuid"
)

const createUnit = `-- name: CreateUnit :one
INSERT INTO units (
  faction_id, name, description, is_manifestation, is_unique,
  move, health, save, ward, control, points,
  summon_cost, banishment,
  min_unit_size, max_unit_size, matched_play, version, source
)
VALUES (
  $1, $2, $3, $4, $5,
  $6, $7, $8, $9, $10, $11,
  $12, $13,
  $14, $15, $16, $17, $18
)
RETURNING id, faction_id, name, description, is_manifestation, is_unique, move, health, save, ward, control, points, summon_cost, banishment, min_unit_size, max_unit_size, matched_play, version, source, created_at, updated_at
`

type CreateUnitParams struct {
	FactionID       uuid.UUID
	Name            string
	Description     string
	IsManifestation bool
	IsUnique        bool
	Move            int32
	Health          int32
	Save            string
	Ward            string
	Control         int32
	Points          int32
	SummonCost      string
	Banishment      string
	MinUnitSize     int32
	MaxUnitSize     int32
	MatchedPlay     bool
	Version         string
	Source          string
}

func (q *Queries) CreateUnit(ctx context.Context, arg CreateUnitParams) (Unit, error) {
	row := q.db.QueryRow(ctx, createUnit,
		arg.FactionID,
		arg.Name,
		arg.Description,
		arg.IsManifestation,
		arg.IsUnique,
		arg.Move,
		arg.Health,
		arg.Save,
		arg.Ward,
		arg.Control,
		arg.Points,
		arg.SummonCost,
		arg.Banishment,
		arg.MinUnitSize,
		arg.MaxUnitSize,
		arg.MatchedPlay,
		arg.Version,
		arg.Source,
	)
	var i Unit
	err := row.Scan(
		&i.ID,
		&i.FactionID,
		&i.Name,
		&i.Description,
		&i.IsManifestation,
		&i.IsUnique,
		&i.Move,
		&i.Health,
		&i.Save,
		&i.Ward,
		&i.Control,
		&i.Points,
		&i.SummonCost,
		&i.Banishment,
		&i.MinUnitSize,
		&i.MaxUnitSize,
		&i.MatchedPlay,
		&i.Version,
		&i.Source,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteUnit = `-- name: DeleteUnit :exec
DELETE FROM units
WHERE id = $1
`

func (q *Queries) DeleteUnit(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteUnit, id)
	return err
}

const getAllUnits = `-- name: GetAllUnits :many
SELECT id, faction_id, name, description, is_manifestation, is_unique, move, health, save, ward, control, points, summon_cost, banishment, min_unit_size, max_unit_size, matched_play, version, source, created_at, updated_at
FROM units
WHERE is_manifestation = false
ORDER BY faction_id, name ASC
`

func (q *Queries) GetAllUnits(ctx context.Context) ([]Unit, error) {
	rows, err := q.db.Query(ctx, getAllUnits)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Unit
	for rows.Next() {
		var i Unit
		if err := rows.Scan(
			&i.ID,
			&i.FactionID,
			&i.Name,
			&i.Description,
			&i.IsManifestation,
			&i.IsUnique,
			&i.Move,
			&i.Health,
			&i.Save,
			&i.Ward,
			&i.Control,
			&i.Points,
			&i.SummonCost,
			&i.Banishment,
			&i.MinUnitSize,
			&i.MaxUnitSize,
			&i.MatchedPlay,
			&i.Version,
			&i.Source,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getManifestationByID = `-- name: GetManifestationByID :one
SELECT id, faction_id, name, description, is_manifestation, is_unique, move, health, save, ward, control, points, summon_cost, banishment, min_unit_size, max_unit_size, matched_play, version, source, created_at, updated_at
FROM units
WHERE id = $1 AND is_manifestation = true
`

func (q *Queries) GetManifestationByID(ctx context.Context, id uuid.UUID) (Unit, error) {
	row := q.db.QueryRow(ctx, getManifestationByID, id)
	var i Unit
	err := row.Scan(
		&i.ID,
		&i.FactionID,
		&i.Name,
		&i.Description,
		&i.IsManifestation,
		&i.IsUnique,
		&i.Move,
		&i.Health,
		&i.Save,
		&i.Ward,
		&i.Control,
		&i.Points,
		&i.SummonCost,
		&i.Banishment,
		&i.MinUnitSize,
		&i.MaxUnitSize,
		&i.MatchedPlay,
		&i.Version,
		&i.Source,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getManifestations = `-- name: GetManifestations :many
SELECT id, faction_id, name, description, is_manifestation, is_unique, move, health, save, ward, control, points, summon_cost, banishment, min_unit_size, max_unit_size, matched_play, version, source, created_at, updated_at
FROM units
WHERE is_manifestation = true
ORDER BY faction_id, name ASC
`

func (q *Queries) GetManifestations(ctx context.Context) ([]Unit, error) {
	rows, err := q.db.Query(ctx, getManifestations)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Unit
	for rows.Next() {
		var i Unit
		if err := rows.Scan(
			&i.ID,
			&i.FactionID,
			&i.Name,
			&i.Description,
			&i.IsManifestation,
			&i.IsUnique,
			&i.Move,
			&i.Health,
			&i.Save,
			&i.Ward,
			&i.Control,
			&i.Points,
			&i.SummonCost,
			&i.Banishment,
			&i.MinUnitSize,
			&i.MaxUnitSize,
			&i.MatchedPlay,
			&i.Version,
			&i.Source,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNonManifestationUnits = `-- name: GetNonManifestationUnits :many
SELECT id, faction_id, name, description, is_manifestation, is_unique, move, health, save, ward, control, points, summon_cost, banishment, min_unit_size, max_unit_size, matched_play, version, source, created_at, updated_at
FROM units
WHERE is_manifestation = false
ORDER BY faction_id, name ASC
`

func (q *Queries) GetNonManifestationUnits(ctx context.Context) ([]Unit, error) {
	rows, err := q.db.Query(ctx, getNonManifestationUnits)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Unit
	for rows.Next() {
		var i Unit
		if err := rows.Scan(
			&i.ID,
			&i.FactionID,
			&i.Name,
			&i.Description,
			&i.IsManifestation,
			&i.IsUnique,
			&i.Move,
			&i.Health,
			&i.Save,
			&i.Ward,
			&i.Control,
			&i.Points,
			&i.SummonCost,
			&i.Banishment,
			&i.MinUnitSize,
			&i.MaxUnitSize,
			&i.MatchedPlay,
			&i.Version,
			&i.Source,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUnitByID = `-- name: GetUnitByID :one
SELECT id, faction_id, name, description, is_manifestation, is_unique, move, health, save, ward, control, points, summon_cost, banishment, min_unit_size, max_unit_size, matched_play, version, source, created_at, updated_at
FROM units
WHERE id = $1
`

func (q *Queries) GetUnitByID(ctx context.Context, id uuid.UUID) (Unit, error) {
	row := q.db.QueryRow(ctx, getUnitByID, id)
	var i Unit
	err := row.Scan(
		&i.ID,
		&i.FactionID,
		&i.Name,
		&i.Description,
		&i.IsManifestation,
		&i.IsUnique,
		&i.Move,
		&i.Health,
		&i.Save,
		&i.Ward,
		&i.Control,
		&i.Points,
		&i.SummonCost,
		&i.Banishment,
		&i.MinUnitSize,
		&i.MaxUnitSize,
		&i.MatchedPlay,
		&i.Version,
		&i.Source,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUnitsByFaction = `-- name: GetUnitsByFaction :many
SELECT id, faction_id, name, description, is_manifestation, is_unique, move, health, save, ward, control, points, summon_cost, banishment, min_unit_size, max_unit_size, matched_play, version, source, created_at, updated_at
FROM units
WHERE faction_id = $1 AND is_manifestation = false
ORDER BY name ASC
`

func (q *Queries) GetUnitsByFaction(ctx context.Context, factionID uuid.UUID) ([]Unit, error) {
	rows, err := q.db.Query(ctx, getUnitsByFaction, factionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Unit
	for rows.Next() {
		var i Unit
		if err := rows.Scan(
			&i.ID,
			&i.FactionID,
			&i.Name,
			&i.Description,
			&i.IsManifestation,
			&i.IsUnique,
			&i.Move,
			&i.Health,
			&i.Save,
			&i.Ward,
			&i.Control,
			&i.Points,
			&i.SummonCost,
			&i.Banishment,
			&i.MinUnitSize,
			&i.MaxUnitSize,
			&i.MatchedPlay,
			&i.Version,
			&i.Source,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUnitsByMatchedPlay = `-- name: GetUnitsByMatchedPlay :many
SELECT id, faction_id, name, description, is_manifestation, is_unique, move, health, save, ward, control, points, summon_cost, banishment, min_unit_size, max_unit_size, matched_play, version, source, created_at, updated_at
FROM units
WHERE faction_id = $1 AND matched_play = true AND is_manifestation = false
ORDER BY name ASC
`

func (q *Queries) GetUnitsByMatchedPlay(ctx context.Context, factionID uuid.UUID) ([]Unit, error) {
	rows, err := q.db.Query(ctx, getUnitsByMatchedPlay, factionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Unit
	for rows.Next() {
		var i Unit
		if err := rows.Scan(
			&i.ID,
			&i.FactionID,
			&i.Name,
			&i.Description,
			&i.IsManifestation,
			&i.IsUnique,
			&i.Move,
			&i.Health,
			&i.Save,
			&i.Ward,
			&i.Control,
			&i.Points,
			&i.SummonCost,
			&i.Banishment,
			&i.MinUnitSize,
			&i.MaxUnitSize,
			&i.MatchedPlay,
			&i.Version,
			&i.Source,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateUnit = `-- name: UpdateUnit :one
UPDATE units
SET name = $2, description = $3, move = $4, health = $5, save = $6, ward = $7,
    control = $8, points = $9, summon_cost = $10, banishment = $11,
    min_unit_size = $12, max_unit_size = $13, matched_play = $14, version = $15, source = $16, updated_at = now()
WHERE id = $1
RETURNING id, faction_id, name, description, is_manifestation, is_unique, move, health, save, ward, control, points, summon_cost, banishment, min_unit_size, max_unit_size, matched_play, version, source, created_at, updated_at
`

type UpdateUnitParams struct {
	ID          uuid.UUID
	Name        string
	Description string
	Move        int32
	Health      int32
	Save        string
	Ward        string
	Control     int32
	Points      int32
	SummonCost  string
	Banishment  string
	MinUnitSize int32
	MaxUnitSize int32
	MatchedPlay bool
	Version     string
	Source      string
}

func (q *Queries) UpdateUnit(ctx context.Context, arg UpdateUnitParams) (Unit, error) {
	row := q.db.QueryRow(ctx, updateUnit,
		arg.ID,
		arg.Name,
		arg.Description,
		arg.Move,
		arg.Health,
		arg.Save,
		arg.Ward,
		arg.Control,
		arg.Points,
		arg.SummonCost,
		arg.Banishment,
		arg.MinUnitSize,
		arg.MaxUnitSize,
		arg.MatchedPlay,
		arg.Version,
		arg.Source,
	)
	var i Unit
	err := row.Scan(
		&i.ID,
		&i.FactionID,
		&i.Name,
		&i.Description,
		&i.IsManifestation,
		&i.IsUnique,
		&i.Move,
		&i.Health,
		&i.Save,
		&i.Ward,
		&i.Control,
		&i.Points,
		&i.SummonCost,
		&i.Banishment,
		&i.MinUnitSize,
		&i.MaxUnitSize,
		&i.MatchedPlay,
		&i.Version,
		&i.Source,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
